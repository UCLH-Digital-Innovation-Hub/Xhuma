name: Deploy to Azure with Terraform

# This workflow will only run when:
# 1. A PR to the play branch is merged
# 2. It's manually triggered via the Actions tab

on:
  pull_request:
    types: [closed]
    branches: [ play ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'rg-xhuma-play'
        type: choice
        options:
          - rg-xhuma-play
          - rg-xhuma-dev
          - rg-xhuma-test
          - rg-xhuma-prod

jobs:
  terraform:
    # Only run when PR is merged, not when it's closed without merging
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for file change detection
    
    - name: Set environment variables
      id: env-vars
      run: |
        echo "ENVIRONMENT=rg-xhuma-play" >> $GITHUB_ENV
        # Extract the base environment name without prefixes for proper naming
        echo "ENV_BASE_NAME=play" >> $GITHUB_ENV
    
    - name: Debug credentials
      run: |
        # Log that we're about to authenticate (don't show any secrets)
        echo "Preparing to authenticate with Azure..."
        # Check if the AZURE_CREDENTIALS secret exists (without revealing its content)
        if [ -n "${{ secrets.AZURE_CREDENTIALS }}" ]; then
          echo "AZURE_CREDENTIALS secret is set"
        else
          echo "AZURE_CREDENTIALS secret is NOT set"
        fi
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.10.5
    
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Select Azure subscription
      run: |
        az account show
        az account set --subscription "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
    
    - name: Check if resources exist
      id: resource-check
      run: |
        cd azure/terraform
        # Check if resource group exists
        RESOURCE_GROUP_EXISTS=$(az group exists --name ${{ env.ENVIRONMENT }} --query bool -o tsv)
        echo "RESOURCE_GROUP_EXISTS=$RESOURCE_GROUP_EXISTS" >> $GITHUB_ENV
        echo "::set-output name=resource_group_exists::$RESOURCE_GROUP_EXISTS"
        
        # Log the resource group status
        echo "Resource group ${{ env.ENVIRONMENT }} exists: $RESOURCE_GROUP_EXISTS"
    
    - name: Initialize Terraform
      run: |
        cd azure/terraform
        terraform init
    
    # Separate step for direct imports - will run regardless of previous script success/failure
    - name: Direct import of Azure resources
      run: |
        cd azure/terraform
        echo "Starting direct import of resources..."
        
        # Get the subscription ID
        SUBSCRIPTION_ID=$(az account show --query id -o tsv)
        echo "Using subscription ID: $SUBSCRIPTION_ID"
        
        # Get resource group info
        echo "Checking resource group ${{ env.ENVIRONMENT }}..."
        az group show --name ${{ env.ENVIRONMENT }} || true
        
        # Display existing resources in the resource group for debugging
        echo "Listing resources in resource group ${{ env.ENVIRONMENT }}..."
        az resource list --resource-group ${{ env.ENVIRONMENT }} --query "[].{name:name, type:type}" -o table || true
        
        # Verify no stale resources exist for Key Vault
        echo "Checking for soft-deleted Key Vault..."
        az keyvault list-deleted --query "[?name=='kvxhuma${{ env.ENV_BASE_NAME }}']" || true
        if az keyvault list-deleted --query "[?name=='kvxhuma${{ env.ENV_BASE_NAME }}']" | grep -q "kvxhuma${{ env.ENV_BASE_NAME }}"; then
          echo "Found soft-deleted Key Vault, purging..."
          az keyvault purge --name "kvxhuma${{ env.ENV_BASE_NAME }}" --no-wait || true
        fi
        
        # Direct imports for each resource
        echo "*** Importing Container Registry ***"
        az acr show --name "crxhuma${{ env.ENV_BASE_NAME }}" --resource-group "${{ env.ENVIRONMENT }}" || true
        terraform import module.acr.azurerm_container_registry.acr "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.ENVIRONMENT }}/providers/Microsoft.ContainerRegistry/registries/crxhuma${{ env.ENV_BASE_NAME }}" || echo "Failed to import ACR"
        
        echo "*** Importing Storage Account ***"
        az storage account show --name "st${{ env.ENV_BASE_NAME }}xhuma" --resource-group "${{ env.ENVIRONMENT }}" || true
        terraform import module.storage.azurerm_storage_account.storage "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.ENVIRONMENT }}/providers/Microsoft.Storage/storageAccounts/st${{ env.ENV_BASE_NAME }}xhuma" || echo "Failed to import Storage Account"
        
        # Import the file shares that exist within the Storage Account
        echo "*** Importing Storage Shares ***"
        # Get storage account key for file share operations
        STORAGE_KEY=$(az storage account keys list --account-name "st${{ env.ENV_BASE_NAME }}xhuma" --resource-group "${{ env.ENVIRONMENT }}" --query "[0].value" -o tsv)
        
        # Check if redis-data share exists and import it
        if az storage share exists --name "redis-data" --account-name "st${{ env.ENV_BASE_NAME }}xhuma" --account-key "$STORAGE_KEY" --query "exists" -o tsv | grep -q "true"; then
          echo "Importing redis-data file share..."
          terraform import 'module.storage.azurerm_storage_share.file_shares["redis-data"]' "st${{ env.ENV_BASE_NAME }}xhuma/redis-data" || echo "Failed to import redis-data share"
        fi
        
        # Check if postgres-data share exists and import it
        if az storage share exists --name "postgres-data" --account-name "st${{ env.ENV_BASE_NAME }}xhuma" --account-key "$STORAGE_KEY" --query "exists" -o tsv | grep -q "true"; then
          echo "Importing postgres-data file share..."
          terraform import 'module.storage.azurerm_storage_share.file_shares["postgres-data"]' "st${{ env.ENV_BASE_NAME }}xhuma/postgres-data" || echo "Failed to import postgres-data share"
        fi
        
        echo "*** Importing Key Vault ***"
        az keyvault show --name "kvxhuma${{ env.ENV_BASE_NAME }}01" --resource-group "${{ env.ENVIRONMENT }}" || true
        terraform import module.key_vault.azurerm_key_vault.key_vault "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.ENVIRONMENT }}/providers/Microsoft.KeyVault/vaults/kvxhuma${{ env.ENV_BASE_NAME }}01" || echo "Failed to import Key Vault"
        
        echo "*** Importing Log Analytics Workspace ***"
        az monitor log-analytics workspace show --workspace-name "logxhuma${{ env.ENV_BASE_NAME }}" --resource-group "${{ env.ENVIRONMENT }}" || true
        terraform import module.log_analytics.azurerm_log_analytics_workspace.workspace "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.ENVIRONMENT }}/providers/Microsoft.OperationalInsights/workspaces/logxhuma${{ env.ENV_BASE_NAME }}" || echo "Failed to import Log Analytics"
        
        echo "*** Importing Container Apps Environment ***"
        az containerapp env show --name "caexhuma${{ env.ENV_BASE_NAME }}" --resource-group "${{ env.ENVIRONMENT }}" || true
        terraform import module.container_apps_environment.azurerm_container_app_environment.env "/subscriptions/${SUBSCRIPTION_ID}/resourceGroups/${{ env.ENVIRONMENT }}/providers/Microsoft.App/managedEnvironments/caexhuma${{ env.ENV_BASE_NAME }}" || echo "Failed to import Container Apps Environment"
        
        echo "Import operations completed"
    
    - name: Terraform Init
      run: |
        cd azure/terraform
        terraform init
    
    - name: Terraform Validate
      run: |
        cd azure/terraform
        terraform validate
    
    - name: Detect change type
      id: change-detection
      run: |
        cd azure/terraform
        # Run a terraform plan and save changes to a file
        terraform plan \
          -var="environment=${{ env.ENVIRONMENT }}" \
          -var="redis_password=${{ secrets.REDIS_PASSWORD }}" \
          -var="postgres_password=${{ secrets.POSTGRES_PASSWORD }}" \
          -var="api_key=${{ secrets.API_KEY }}" \
          -var="grafana_admin_password=${{ secrets.GRAFANA_ADMIN_PASSWORD }}" \
          -out=tfplan
        
        # Default to infrastructure changes - this ensures the workflow continues
        # even if JSON parsing fails
        CHANGE_TYPE="infrastructure"
        echo "CHANGE_TYPE=$CHANGE_TYPE" >> $GITHUB_ENV
        echo "::set-output name=change_type::$CHANGE_TYPE"
        
        # Only try jq if we want to be more specific (but don't fail the build)
        set +e # Don't exit on error
        PLAN_JSON=$(terraform show -json tfplan 2>/dev/null)
        if [ $? -eq 0 ] && [ -n "$PLAN_JSON" ]; then
          INFRA_CHANGES=$(echo "$PLAN_JSON" | jq '.resource_changes | length' 2>/dev/null)
          if [ $? -eq 0 ] && [ -n "$INFRA_CHANGES" ]; then
            if [ "$INFRA_CHANGES" -gt "0" ]; then
              CHANGE_TYPE="infrastructure"
            else
              CHANGE_TYPE="application"
            fi
            echo "CHANGE_TYPE=$CHANGE_TYPE" >> $GITHUB_ENV
            echo "::set-output name=change_type::$CHANGE_TYPE"
          fi
        fi
        # Regardless of parsing success, report what we're doing
        echo "Proceeding with change type: $CHANGE_TYPE"
    
    - name: Terraform Apply
      run: |
        cd azure/terraform
        terraform apply -auto-approve tfplan
      
    - name: Get Terraform Outputs
      id: terraform-outputs
      run: |
        cd azure/terraform
        # Get ACR details and export to environment variables for the next job
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server || echo "")
        if [ -n "$ACR_LOGIN_SERVER" ]; then
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
          echo "::set-output name=acr_login_server::$ACR_LOGIN_SERVER"
        else
          # Fallback to secrets if terraform output is not available
          echo "ACR_LOGIN_SERVER=${{ secrets.ACR_LOGIN_SERVER }}" >> $GITHUB_ENV
          echo "::set-output name=acr_login_server::${{ secrets.ACR_LOGIN_SERVER }}"
        fi
  
  build-and-push:
    needs: terraform
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for file change detection
    
    - name: Determine if app changes exist
      id: app-changes
      run: |
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          # Get list of changed files in PR
          CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }})
        elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # If manually triggered, assume app changes
          CHANGED_FILES="app/"
        fi
        
        # Check if app code was changed
        if echo "$CHANGED_FILES" | grep -q "^app/"; then
          echo "REBUILD_REQUIRED=true" >> $GITHUB_ENV
        else
          echo "REBUILD_REQUIRED=false" >> $GITHUB_ENV
        fi
    
    - name: Set up Docker Buildx
      if: env.REBUILD_REQUIRED == 'true'
      uses: docker/setup-buildx-action@v1
    
    - name: Login to Azure
      if: env.REBUILD_REQUIRED == 'true'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Login to Azure Container Registry
      if: env.REBUILD_REQUIRED == 'true'
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.ACR_LOGIN_SERVER }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}
    
    - name: Build and push Xhuma image
      if: env.REBUILD_REQUIRED == 'true'
      uses: docker/build-push-action@v3
      with:
        context: .
        push: true
        tags: ${{ env.ACR_LOGIN_SERVER }}/xhuma:${{ github.sha }},${{ env.ACR_LOGIN_SERVER }}/xhuma:latest
