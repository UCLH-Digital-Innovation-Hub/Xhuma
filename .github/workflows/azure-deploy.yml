name: Deploy to Azure with Terraform

# This workflow will only run when:
# 1. A PR to the play branch is merged
# 2. It's manually triggered via the Actions tab

on:
  pull_request:
    types: [closed]
    branches: [ play ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'rg-xhuma-play'
        type: choice
        options:
          - rg-xhuma-play
          - rg-xhuma-dev
          - rg-xhuma-test
          - rg-xhuma-prod

jobs:
  terraform:
    # Only run when PR is merged, not when it's closed without merging
    if: github.event.pull_request.merged == true || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for file change detection
    
    - name: Set environment variables
      id: env-vars
      run: |
        echo "ENVIRONMENT=rg-xhuma-play" >> $GITHUB_ENV
        # Extract the base environment name without prefixes for proper naming
        echo "ENV_BASE_NAME=play" >> $GITHUB_ENV
    
    - name: Debug credentials
      run: |
        # Log that we're about to authenticate (don't show any secrets)
        echo "Preparing to authenticate with Azure..."
        # Check if the AZURE_CREDENTIALS secret exists (without revealing its content)
        if [ -n "${{ secrets.AZURE_CREDENTIALS }}" ]; then
          echo "AZURE_CREDENTIALS secret is set"
        else
          echo "AZURE_CREDENTIALS secret is NOT set"
        fi
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v2
      with:
        terraform_version: 1.10.5
    
    - name: Login to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Select Azure subscription
      run: |
        az account show
        az account set --subscription "${{ secrets.AZURE_SUBSCRIPTION_ID }}"
    
    - name: Check if resources exist
      run: |
        cd azure/terraform
        # Check if resource group exists
        RESOURCE_GROUP_EXISTS=$(az group exists --name ${{ env.ENVIRONMENT }} --query bool -o tsv)
        echo "RESOURCE_GROUP_EXISTS=$RESOURCE_GROUP_EXISTS" >> $GITHUB_ENV
    
    - name: Import existing resources (if applicable)
      if: env.RESOURCE_GROUP_EXISTS == 'true'
      run: |
        cd azure/terraform
        # Make script executable
        chmod +x ./import-resources.sh
        # Run the import script with the resource group
        ./import-resources.sh -g ${{ env.ENVIRONMENT }}
        
        # Verify no stale resources exist for Key Vault
        echo "Checking for soft-deleted Key Vault..."
        if az keyvault list-deleted --query "[?name=='kvxhuma${{ env.ENV_BASE_NAME }}']" | grep -q "kvxhuma${{ env.ENV_BASE_NAME }}"; then
          echo "Found soft-deleted Key Vault, purging..."
          az keyvault purge --name "kvxhuma${{ env.ENV_BASE_NAME }}" --no-wait || true
        fi
    
    - name: Terraform Init
      run: |
        cd azure/terraform
        terraform init
    
    - name: Terraform Validate
      run: |
        cd azure/terraform
        terraform validate
    
    - name: Detect change type
      id: change-detection
      run: |
        cd azure/terraform
        # Run a terraform plan and save changes to a file
        terraform plan \
          -var="environment=${{ env.ENVIRONMENT }}" \
          -var="redis_password=${{ secrets.REDIS_PASSWORD }}" \
          -var="postgres_password=${{ secrets.POSTGRES_PASSWORD }}" \
          -var="api_key=${{ secrets.API_KEY }}" \
          -var="grafana_admin_password=${{ secrets.GRAFANA_ADMIN_PASSWORD }}" \
          -out=tfplan
        
        # Default to infrastructure changes - this ensures the workflow continues
        # even if JSON parsing fails
        CHANGE_TYPE="infrastructure"
        echo "CHANGE_TYPE=$CHANGE_TYPE" >> $GITHUB_ENV
        echo "::set-output name=change_type::$CHANGE_TYPE"
        
        # Only try jq if we want to be more specific (but don't fail the build)
        set +e # Don't exit on error
        PLAN_JSON=$(terraform show -json tfplan 2>/dev/null)
        if [ $? -eq 0 ] && [ -n "$PLAN_JSON" ]; then
          INFRA_CHANGES=$(echo "$PLAN_JSON" | jq '.resource_changes | length' 2>/dev/null)
          if [ $? -eq 0 ] && [ -n "$INFRA_CHANGES" ]; then
            if [ "$INFRA_CHANGES" -gt "0" ]; then
              CHANGE_TYPE="infrastructure"
            else
              CHANGE_TYPE="application"
            fi
            echo "CHANGE_TYPE=$CHANGE_TYPE" >> $GITHUB_ENV
            echo "::set-output name=change_type::$CHANGE_TYPE"
          fi
        fi
        # Regardless of parsing success, report what we're doing
        echo "Proceeding with change type: $CHANGE_TYPE"
    
    - name: Terraform Apply
      run: |
        cd azure/terraform
        terraform apply -auto-approve tfplan
      
    - name: Get Terraform Outputs
      id: terraform-outputs
      run: |
        cd azure/terraform
        # Get ACR details and export to environment variables for the next job
        ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server || echo "")
        if [ -n "$ACR_LOGIN_SERVER" ]; then
          echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER" >> $GITHUB_ENV
          echo "::set-output name=acr_login_server::$ACR_LOGIN_SERVER"
        else
          # Fallback to secrets if terraform output is not available
          echo "ACR_LOGIN_SERVER=${{ secrets.ACR_LOGIN_SERVER }}" >> $GITHUB_ENV
          echo "::set-output name=acr_login_server::${{ secrets.ACR_LOGIN_SERVER }}"
        fi
  
  build-and-push:
    needs: terraform
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Fetch all history for file change detection
    
    - name: Determine if app changes exist
      id: app-changes
      run: |
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          # Get list of changed files in PR
          CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }})
        elif [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          # If manually triggered, assume app changes
          CHANGED_FILES="app/"
        fi
        
        # Check if app code was changed
        if echo "$CHANGED_FILES" | grep -q "^app/"; then
          echo "REBUILD_REQUIRED=true" >> $GITHUB_ENV
        else
          echo "REBUILD_REQUIRED=false" >> $GITHUB_ENV
        fi
    
    - name: Set up Docker Buildx
      if: env.REBUILD_REQUIRED == 'true'
      uses: docker/setup-buildx-action@v1
    
    - name: Login to Azure
      if: env.REBUILD_REQUIRED == 'true'
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Login to Azure Container Registry
      if: env.REBUILD_REQUIRED == 'true'
      uses: azure/docker-login@v1
      with:
        login-server: ${{ env.ACR_LOGIN_SERVER }}
        username: ${{ secrets.ACR_USERNAME }}
        password: ${{ secrets.ACR_PASSWORD }}
    
    - name: Build and push Xhuma image
      if: env.REBUILD_REQUIRED == 'true'
      uses: docker/build-push-action@v3
      with:
        context: .
        push: true
        tags: ${{ env.ACR_LOGIN_SERVER }}/xhuma:${{ github.sha }},${{ env.ACR_LOGIN_SERVER }}/xhuma:latest
